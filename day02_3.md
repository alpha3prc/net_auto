---
marp: true
theme: gaia
class: _lead
size: 16:9
headingDivider: [2,3]
paginate: true
---

<!-- _class: lead -->

# **多线程原理**
## **多线程的动机**

*   在多线程 (MT) 编程出现之前，电脑程序的运行由一个执行序列组成，执行序列按顺序在主机的中央处理器 (CPU) 中运行
*   无论是任务本身要求顺序执行还是整个程序是由多个子任务组成，程序都是按这种方式执行的
*   即使子任务相互独立，互不相关（即，一个子任务的结果不影响其它子任务的结果）时也是这样
*   如果并行运行这些相互独立的子任务可以大幅度地提升整个任务的效率
## **多线程任务的工作特点**

*   它们本质上就是异步的，需要有多个并发事务
*   各个事务的运行顺序可以是不确定的，随机的，不可预测的
*   这样的编程任务可以被分成多个执行流，每个流都有一个要完成的目标
*   根据应用的不同，这些子任务可能都要计算出一个中间结果，用于合并得到最后的结果

## **什么是进程**

*   计算机程序只不过是磁盘中可执行的、二进制（或其它类型）的数据
*   进程（有时被称为重量级进程）是程序的一次执行
*   每个进程都有自己的地址空间、内存以及其它记录其运行轨迹的辅助数据
*   操作系统管理在其上运行的所有进程，并为这些进程公平地分配时间

## **什么是线程**

*   线程（有时被称为轻量级进程）跟进程有些相似。不同的是，所有的线程运行在同一个进程中，共享相同的运行环境
*   一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯

@@

## **多线程相关模块**

*   `thread` 和 `threading` 模块允许程序员创建和管理线程
*   `thread` 模块提供了基本的线程和锁的支持，而 `threading` 提供了更高级别、功能更强的线程管理功能
*   推荐使用更高级别的 `threading` 模块

## **传递函数给 Thread 类**

*   多线程编程有多种方法，传递函数给 `threading` 模块的 `Thread` 类是介绍的第一种方法
*   `Thread` 对象使用 `start()` 方法开始线程的执行，使用 `join()` 方法挂起程序，直到线程结束

## **传递可调用类给 Thread 类**

*   传递可用类给 `Thread` 类是介绍的第二种方法
*   相对于一个或几个函数来说，由于类对象里可以使用类的强大的功能，可以保存更多的信息，这种方法更为灵活

### **示例代码`mtprint.py`:**

```python
# 主线程生成工作线程
# 具体的任务由工作线程执行

import threading

def say_hi(tmp):
    print('hello %s' % tmp)

if __name__=='__main__':
    for i in range(3):
        t=threading.Thread(target=say_hi,args=('tedu',))
        t.start()
```



## **案例5：扫描存活主机**

1.  通过ping测试主机是否可达
2.  如果ping不通，不管什么原因都认为主机不可用
3.  通过多线程方式实现并发扫描
### **示例代码`mtping.py`:**
```python
import subprocess
import threading

def ping(host):
    result = subprocess.run(
        'ping -c2 %s > /dev/null 2>&1' % host, shell=True
    )
    if result.returncode == 0:
        print('%s:up' % host)
    else:
        print('%s:down' % host)

if __name__ == '__main__':
    ips=['192.168.150.%s' % i for i in range(1, 255)]
    for ip in ips:
        t=threading.Thread(target=ping,args=(ip,))
        t.start()
```

### **oop方式`mtprint2.py`**

```python
import subprocess
import threading

class Ping:
    def __call__(self,host):
        result = subprocess.run(
            'ping -c2 %s > /dev/null 2>&1' % host, shell=True
        )
        if result.returncode == 0:
            print('%s:up' % host)
        else:
            print('%s:down' % host)

if __name__ == '__main__':
    ips=['192.168.150.%s' % i for i in range(1, 255)]
    for ip in ips:
        t=threading.Thread(target=Ping(),args=(ip,))
        t.start()  #三个magic __init__,__str__,__call__
```

### **熟悉的`__init__`方式`mtping3.py`:**

```python
import subprocess
import threading

class Ping:
    def __init__(self,host):
        self.host=host
    def __call__(self):
        result = subprocess.run(
            'ping -c2 %s > /dev/null 2>&1' % self.host, shell=True
        )
        if result.returncode == 0:
            print('%s:up' % self.host)
        else:
            print('%s:down' % self.host)

if __name__ == '__main__':
    ips=['192.168.150.%s' % i for i in range(1, 255)]
    for ip in ips:
        t=threading.Thread(target=Ping(ip))
        t.start()  #三个magic __init__,__str__,__call__
```

## **小结**

- 多线程工作原理
- 多线程编程
<!-- 多线程和多进程的区别,win支持多线程但不支持多进程,使用的threading模块,threading.thread创建实例,传参args,启动t.start -->